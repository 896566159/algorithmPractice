package ltcd.stackExercise;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashSet;
import java.util.Set;

public class _85_最大矩形 {



    public static void main(String[] args) {
        _85_最大矩形 v = new _85_最大矩形();
//        System.out.println(v.maximalRectangle1(new char[][]{{'1', '0'}}));
//        System.out.println(v.maximalRectangle1(new char[][]{{'1'}}));
//        System.out.println(v.maximalRectangle1(new char[][]{{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','0','0','1','1','1','1','1','1','1','1','0','0','1','1','1','0','1','1','1','1','1','1','1','1'},{'1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'0','1','1','1','1','0','1','0','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'0','1','0','1','1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','0','1','1','0','1','1','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','0','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','0','1','1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','0','1','1','1','1','1','1','0','1','1','1','1'},{'0','1','1','0','1','1','0','1','0','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0','1','0','1'},{'0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','0','0','1','1','0','0','1','1','0','1','1','0','1','0','1','0','1'},{'1','1','1','1','0','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','1','1','0','1','0','1','1','0','1','0','1','1'},{'1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','1','0','1','1','1','1','0','1','1','1','1'},{'1','1','1','0','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'1','0','1','1','1','1','1','1','1','0','1','1','1','1','0','1','1','1','1','0','0','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0','1','1'},{'1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','0','1','0','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1'},{'1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1'},{'1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','0','1','1','1','1','1','1','0','0','1','1','1','1','1'},{'1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1'},{'1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','0','1','1','1','1','1','0','0','1','0','1','1','1','1','1','0','1','1','1','1','1','1'},{'1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','0','1','1','0','1','1'},{'1','1','0','0','0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1'},{'1','1','1','1','1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','0','1','0','1','1','1','0','0','1','1','1','1','1','1','1','1'},{'1','1','1','0','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','0','1','1','1','1','0','1','1','1','1','1','0','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1'},{'1','1','1','1','1','1','1','0','1','1','1','1','1','1','0','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1'},{'1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0','0','1','1','1','1','1','1','1','1','1','0','1','1','1','0','1'},{'1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','0','1','1','1','0','1','1','0','1','1'},{'1','1','1','1','0','1','1','0','1','1','1','1','1','1','0','1','1','0','1','1','0','1','1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'1','1','0','0','0','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1'},{'1','1','1','1','1','0','1','1','1','1','1','1','1','1','0','1','1','1','1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'0','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','0','1','0','1','0','1','1','0','1','1','1','1','1','1','1','1'},{'1','0','1','1','0','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1'},{'1','0','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1'},{'0','1','1','1','1','0','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1'},{'0','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','0','1','1','1','0','1','1','1','1','0','1','1','1','0','1','1','1','1','1','1','1','1','1','1'},{'0','1','1','1','1','1','1','1','1','1','1','1','0','1','0','1','1','1','1','0','1','1','1','1','1','1','0','1','0','1','1','0','0','1','1','1','1','0','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','0','1','1','1','0'},{'1','1','1','1','1','0','1','1','1','1','1','1','1','1','0','0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0','0','1','1','1','1'},{'1','1','0','1','1','0','1','1','1','1','1','1','0','1','0','1','1','1','1','1','0','1','1','1','1','1','1','1','1','0','0','1','1','1','0','1','0','1','0','0'},{'0','1','1','0','1','1','1','1','1','1','1','0','0','1','1','1','1','1','0','0','1','0','1','1','1','1','1','0','1','1','1','0','1','1','0','1','1','1','0','1'}}));
//        System.out.println(v.maximalRectangle(new char[][]{{'1', '0', '1', '0', '0'}, {'1', '0', '1', '1', '1'}, {'1', '1', '1', '1', '1'}}));
//        System.out.println(v.maximalRectangle(new char[][]{
//                {'1','1','1','1','1','1','1','1'},
//                {'1','1','1','1','1','1','1','0'},
//                {'1','1','1','1','1','1','1','0'},
//                {'1','1','1','1','1','0','0','0'},
//                {'0','1','1','1','1','0','0','0'}
//        }));

//        System.out.println(v.maximalRectangle(new char[][]{
//                {'1', '0', '1', '1', '0', '1'},
//                {'1', '1', '1', '1', '1', '1'},
//                {'0', '1', '1', '0', '1', '1'},
//                {'1', '1', '1', '0', '1', '0'},
//                {'0', '1', '1', '1', '1', '1'},
//                {'1', '1', '0', '1', '1', '1'}
//        }));
//        System.out.println(v.maximalRectangle1(new char[][]{{'1','0','1','0','0'},{'1','0','1','1','1'},{'1','1','1','1','1'},{'1','0','0','1','0'}}));
        System.out.println(v.maximalRectangle1(new char[][]{{'0','1'},{'1','0'}}));
    }

    int maxMatrix = 0;
    public int maximalRectangle1(char[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int m = matrix.length;
        int n = matrix[0].length;
        int ans = 0;
        // 矩阵的从上到下，每一行的前缀和
        int[][] preSum = new int[m + 1][n + 2];

        // 前缀和求解
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    preSum[i + 1][j + 1] = preSum[i][j + 1] + 1;
                }
            }
        }

        // 以每一行为矩形的底部，计算出最大的矩阵面积
        for (int i = 1; i <= m; i++) {
            // 栈，构造一个单调递增栈，方便找出每一个元素的左边、右边第一个比其小的数
            Deque<Integer> stack = new ArrayDeque<>();

            for (int j = 0; j <= n + 1; j++) {
                while (!stack.isEmpty() && preSum[i][j] < preSum[i][stack.peek()]) {
                    int height = preSum[i][stack.pop()];
                    ans = Math.max(ans, (j - stack.peek() - 1) * height);
                }

                // 入栈
                stack.push(j);
            }
        }

        return ans;
    }


    // 下面的解法错误，调换递归中的上下左右的次序可以得到不同的答案
    int max = 0;
    Set<String> memo;
    public int maximalRectangle(char[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }

        int m = matrix.length;
        int n = matrix[0].length;
        memo = new HashSet<>();
        dfs(matrix, 0, n - 1, 0, m - 1);

        return max;
    }

    // 下面的解法错误，调换递归中的上下左右的次序可以得到不同的答案
    private void dfs(char[][] matrix, int left, int right, int top, int bottom) {
        if (left > right || top > bottom || left < 0 || right >= matrix[0].length || bottom >= matrix.length || top < 0) {
            return;
        }

        if (memo.contains(left + ""  + right + top + bottom)) {
            return;
        } else {
            memo.add(left + ""  + right + top + bottom);
        }

        int tmpMax = (right - left + 1) * (bottom - top + 1);
        int tmpLeft = left;
        int tmpRight = right;
        int tmpTop = top;
        int tmpBottom = bottom;
        boolean flag = true;
        if (tmpMax < max) {
            return;
        }

        if (tmpMax == 1) {
            if (matrix[top][left] == '1') {
                max = Math.max(tmpMax, max);
            }
            return;
        }



        while (tmpLeft <= tmpRight && tmpTop <= tmpBottom) {

            // 扫描 最下面一行
            for (int i = tmpLeft; i <= tmpRight; i++) {
                if (matrix[tmpBottom][i] == '0') {
                    flag = false;
                    // 缩小列
                    if (!memo.contains((i + 1) + "" + tmpRight + tmpTop + tmpBottom)) {
                        dfs(matrix, i + 1, tmpRight, tmpTop, tmpBottom);
                    }
                    if (!memo.contains(tmpLeft + "" + (i - 1) + tmpTop + tmpBottom)) {
                        dfs(matrix, tmpLeft, i - 1, tmpTop, tmpBottom);
                    }
                    // 缩小行
                    if (!memo.contains(tmpLeft + "" + tmpRight + tmpTop + (tmpBottom - 1))) {
                        dfs(matrix, tmpLeft, tmpRight, tmpTop, tmpBottom - 1);
                    }
                    break;
                }
            }

            // 扫描 最右边一列
            for (int i = tmpTop; i <= tmpBottom; i++) {
                if (matrix[i][tmpRight] == '0') {
                    flag = false;
                    // 缩小列
                    if (!memo.contains(tmpLeft + "" + (tmpRight - 1) + tmpTop + (tmpBottom - 1))) {
                        dfs(matrix, tmpLeft, tmpRight - 1, tmpTop, tmpBottom);
                    }
                    // 缩小行
                    if (!memo.contains(tmpLeft + "" + tmpRight + (i + 1) + tmpBottom)) {
                        dfs(matrix, tmpLeft, tmpRight, i + 1, tmpBottom);
                    }
                    if (!memo.contains(tmpLeft + "" + tmpRight + tmpTop + (i - 1))) {
                        dfs(matrix, tmpLeft, tmpRight, tmpTop, i - 1);
                    }
                    break;
                }
            }

            // 扫描 最左边一列
            for (int i = tmpTop; i <= tmpBottom; i++) {
                if (matrix[i][tmpLeft] == '0') {
                    flag = false;
                    // 缩小列
                    if (!memo.contains((tmpLeft + 1) + "" + tmpRight + tmpTop + tmpBottom)) {
                        dfs(matrix, tmpLeft + 1, tmpRight, tmpTop, tmpBottom);
                    }

                    // 缩小行
                    if (!memo.contains(tmpLeft + "" + tmpRight + (i + 1) + tmpBottom)) {
                        dfs(matrix, tmpLeft, tmpRight, i + 1, tmpBottom);
                    }
                    if (!memo.contains(tmpLeft + "" + tmpRight + tmpTop + (i - 1))) {
                        dfs(matrix, tmpLeft, tmpRight, tmpTop, i - 1);
                    }
                    break;
                }
            }

            // 扫描 最上面一行
            for (int i = tmpLeft; i <= tmpRight; i++) {
                if (matrix[tmpTop][i] == '0') {
                    flag = false;
                    // 缩小列
                    if (!memo.contains(tmpLeft + "" + (i + 1) + tmpTop + tmpBottom)) {
                        dfs(matrix, i + 1, tmpRight, tmpTop, tmpBottom);
                    }
                    if (!memo.contains(tmpLeft + "" + (i - 1) + tmpTop + tmpBottom)) {
                        dfs(matrix, tmpLeft, i - 1, tmpTop, tmpBottom);
                    }
                    // 缩小行
                    if (!memo.contains(tmpLeft + "" + tmpRight + (tmpTop + 1) + tmpBottom)) {
                        dfs(matrix, tmpLeft, tmpRight, tmpTop + 1, tmpBottom);
                    }
                    break;
                }
            }

            tmpLeft++;
            tmpRight--;
            tmpTop++;
            tmpBottom--;
        }

        // 一层一层的遍历都是 1
        if (flag) {
            max = Math.max(tmpMax, max);
            return;
        }
    }

}
